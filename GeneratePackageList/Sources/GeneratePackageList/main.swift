// Copyright © 2021 ZeeZide GmbH. All rights reserved.

import GRDB

let config = Configuration()

let usage = """
USAGE: \(CommandLine.arguments[0]) <path> <arch>

ARGUMENTS:
  path: The path to the database.
  arch: The CPU architecture the RPM files work with.
"""

if CommandLine.argc < 3 {
	print(usage)
	exit(1)
}

let dbQueue = try DatabaseQueue(path: "\(CommandLine.arguments[1])")

addExtraPackages()

let arch = CommandLine.arguments[2]

let packagesWithNoArch = ["tzdata"]

print("""
# packagelist.make
#
# This file is generated by the code in GeneratePackageList - DO NOT EDIT
#
# Created by Helge Heß
# Copyright © 2020 ZeeZide GmbH. All rights reserved.
#
# OK, the `packages_files` is essentially the primary.sqlite.gz I suppose.
# Using this we could avoid the hardcoding of the package hashes:

# "${ALX_BLOBSTORE_URL}/d12a..1537ff7fb02e/glibc-devel-2.26-34.amzn2.\(arch).rpm"
PACKAGE_NAMES = \\
""")

try dbQueue.read { db in
	for package in packageList {
		if let rows = try Row.fetchOne(db, sql: "SELECT pkgId FROM packages WHERE (\"version\" = '\(package.version)') AND (\"name\" = '\(package.name)') AND (\"release\" = '\(package.release)') AND (\"arch\" = '\(packagesWithNoArch.contains(package.name) ? "noarch" : arch)');") {

			print(rows["pkgId"]! + "/\(package.name)-\(package.version)-\(package.release).\(package.name == "tzdata" ? "noarch" : arch).\(package.filenameExtension) \\")
		} else {
			fputs("Unable to find \(package.name)\n", stderr)
		}
	}
}
